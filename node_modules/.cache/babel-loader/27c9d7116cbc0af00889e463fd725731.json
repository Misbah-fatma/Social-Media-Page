{"ast":null,"code":"import _slicedToArray from \"D:/Projects/Work in progress/social-media-app-master/social-media-app-master/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as e from \"react\";\nexport function useDirection(t, n) {\n  var _e$useState = e.useState(\"ltr\"),\n    _e$useState2 = _slicedToArray(_e$useState, 2),\n    r = _e$useState2[0],\n    o = _e$useState2[1],\n    _e$useState3 = e.useState(),\n    _e$useState4 = _slicedToArray(_e$useState3, 2),\n    i = _e$useState4[0],\n    u = _e$useState4[1],\n    c = e.useRef(0);\n  return e.useEffect(function () {\n    if (void 0 === n && null != t && t.parentElement) {\n      var _e = getComputedStyle(t.parentElement);\n      u(_e);\n    }\n  }, [t, n]), e.useEffect(function () {\n    return void 0 === n && function e() {\n      c.current = requestAnimationFrame(function () {\n        var t = null == i ? void 0 : i.direction;\n        t && o(t), e();\n      });\n    }(), function () {\n      return cancelAnimationFrame(c.current);\n    };\n  }, [i, n, o]), n || r;\n}","map":{"version":3,"names":["useDirection","t","n","_e$useState","e","useState","_e$useState2","_slicedToArray","r","o","_e$useState3","_e$useState4","i","u","c","useRef","useEffect","parentElement","getComputedStyle","current","requestAnimationFrame","direction","cancelAnimationFrame"],"sources":["D:\\Projects\\Work in progress\\social-media-app-master\\social-media-app-master\\node_modules\\@radix-ui\\react-use-direction\\dist\\packages\\react\\use-direction\\src\\useDirection.tsx"],"sourcesContent":["import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\n\nexport function useDirection(element: HTMLElement | null, directionProp?: Direction) {\n  const [direction, setDirection] = React.useState<Direction>('ltr');\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const rAFRef = React.useRef<number>(0);\n\n  React.useEffect(() => {\n    // We check inherited direction of the parent instead of the `element` itself.\n    // This is because we internally set the computed `dir` on the element so wouldn't be\n    // able to react to changes to the inherited direction. The `dir` attribute we set should\n    // always sync with the direction prop OR its inherited direction.\n    if (directionProp === undefined && element?.parentElement) {\n      const computedStyle = getComputedStyle(element.parentElement);\n      setComputedStyle(computedStyle);\n    }\n  }, [element, directionProp]);\n\n  React.useEffect(() => {\n    function getDirection() {\n      rAFRef.current = requestAnimationFrame(() => {\n        const dir = computedStyle?.direction as Direction | '' | undefined;\n        if (dir) setDirection(dir);\n        getDirection();\n      });\n    }\n\n    if (directionProp === undefined) getDirection();\n    return () => cancelAnimationFrame(rAFRef.current);\n  }, [computedStyle, directionProp, setDirection]);\n\n  return directionProp || direction;\n}\n"],"mappings":";;OAIO,SAASA,aAAaC,CAAA,EAA6BC,CAAA;EACxD,IAAAC,WAAA,GAAkCC,CAAA,CAAMC,QAAA,CAAoB;IAAAC,YAAA,GAAAC,cAAA,CAAAJ,WAAA;IAArDK,CAAA,GAAAF,YAAA;IAAWG,CAAA,GAAAH,YAAA;IAAAI,YAAA,GACwBN,CAAA,CAAMC,QAAA;IAAAM,YAAA,GAAAJ,cAAA,CAAAG,YAAA;IAAzCE,CAAA,GAAAD,YAAA;IAAeE,CAAA,GAAAF,YAAA;IAChBG,CAAA,GAASV,CAAA,CAAMW,MAAA,CAAe;EA0BpC,OAxBAX,CAAA,CAAMY,SAAA,CAAU;IAKd,SAAsB,MAAlBd,CAAA,YAA+BD,CAAA,IAAAA,CAAA,CAASgB,aAAA,EAAe;MACzD,IAAMb,EAAA,GAAgBc,gBAAA,CAAiBjB,CAAA,CAAQgB,aAAA;MAC/CJ,CAAA,CAAiBT,EAAA;IAAA;EAAA,GAElB,CAACH,CAAA,EAASC,CAAA,IAEbE,CAAA,CAAMY,SAAA,CAAU;IAAA,YASQ,MAAlBd,CAAA,IARJ,SAASE,EAAA;MACPU,CAAA,CAAOK,OAAA,GAAUC,qBAAA,CAAsB;QACrC,IAAMnB,CAAA,GAAM,QAAAW,CAAA,QAAH,IAAGA,CAAA,CAAeS,SAAA;QACvBpB,CAAA,IAAKQ,CAAA,CAAaR,CAAA,GACtBG,CAAA;MAAA;IAAA,CAI6B,IAC1B;MAAA,OAAMkB,oBAAA,CAAqBR,CAAA,CAAOK,OAAA;IAAA;EAAA,GACxC,CAACP,CAAA,EAAeV,CAAA,EAAeO,CAAA,IAE3BP,CAAA,IAAiBM,CAAA;AAAA"},"metadata":{},"sourceType":"module"}