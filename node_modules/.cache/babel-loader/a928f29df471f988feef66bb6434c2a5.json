{"ast":null,"code":"import _slicedToArray from \"D:/Projects/Work in progress/social-media-app-master/social-media-app-master/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useRef, useState, useEffect } from 'react';\nfunction useUncontrolled(_ref) {\n  var value = _ref.value,\n    defaultValue = _ref.defaultValue,\n    finalValue = _ref.finalValue,\n    rule = _ref.rule,\n    onChange = _ref.onChange,\n    onValueUpdate = _ref.onValueUpdate;\n  var shouldBeControlled = rule(value);\n  var modeRef = useRef(\"initial\");\n  var initialValue = rule(defaultValue) ? defaultValue : finalValue;\n  var _useState = useState(initialValue),\n    _useState2 = _slicedToArray(_useState, 2),\n    uncontrolledValue = _useState2[0],\n    setUncontrolledValue = _useState2[1];\n  var effectiveValue = shouldBeControlled ? value : uncontrolledValue;\n  if (!shouldBeControlled && modeRef.current === \"controlled\") {\n    effectiveValue = finalValue;\n  }\n  modeRef.current = shouldBeControlled ? \"controlled\" : \"uncontrolled\";\n  var mode = modeRef.current;\n  var handleChange = function handleChange(nextValue) {\n    typeof onChange === \"function\" && onChange(nextValue);\n    if (mode === \"uncontrolled\") {\n      setUncontrolledValue(nextValue);\n    }\n  };\n  useEffect(function () {\n    if (mode === \"uncontrolled\") {\n      setUncontrolledValue(effectiveValue);\n    }\n    typeof onValueUpdate === \"function\" && onValueUpdate(effectiveValue);\n  }, [mode, effectiveValue]);\n  return [effectiveValue, handleChange, modeRef.current];\n}\nexport { useUncontrolled };","map":{"version":3,"names":["useUncontrolled","_ref","value","defaultValue","finalValue","rule","onChange","onValueUpdate","shouldBeControlled","modeRef","useRef","initialValue","_useState","useState","_useState2","_slicedToArray","uncontrolledValue","setUncontrolledValue","effectiveValue","current","mode","handleChange","nextValue","useEffect"],"sources":["D:\\Projects\\Work in progress\\social-media-app-master\\social-media-app-master\\node_modules\\@mantine\\hooks\\src\\use-uncontrolled\\use-uncontrolled.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nexport type UncontrolledMode = 'initial' | 'controlled' | 'uncontrolled';\n\nexport interface UncontrolledOptions<T> {\n  value: T | null | undefined;\n  defaultValue: T | null | undefined;\n  finalValue: T | null;\n  onChange(value: T | null): void;\n  onValueUpdate?(value: T | null): void;\n  rule: (value: T | null | undefined) => boolean;\n}\n\nexport function useUncontrolled<T>({\n  value,\n  defaultValue,\n  finalValue,\n  rule,\n  onChange,\n  onValueUpdate,\n}: UncontrolledOptions<T>): readonly [T | null, (nextValue: T | null) => void, UncontrolledMode] {\n  // determine, whether new props indicate controlled state\n  const shouldBeControlled = rule(value);\n\n  // initialize state\n  const modeRef = useRef<UncontrolledMode>('initial');\n  const initialValue = rule(defaultValue) ? defaultValue : finalValue;\n  const [uncontrolledValue, setUncontrolledValue] = useState(initialValue);\n\n  // compute effective value\n  let effectiveValue = shouldBeControlled ? value : uncontrolledValue;\n\n  if (!shouldBeControlled && modeRef.current === 'controlled') {\n    // We are transitioning from controlled to uncontrolled\n    // this transition is special as it happens when clearing out\n    // the input using \"invalid\" value (typically null or undefined).\n    //\n    // Since the value is invalid, doing nothing would mean just\n    // transitioning to uncontrolled state and using whatever value\n    // it currently holds which is likely not the behavior\n    // user expects, so lets change the state to finalValue.\n    //\n    // The value will be propagated to internal state by useEffect below.\n\n    effectiveValue = finalValue;\n  }\n\n  modeRef.current = shouldBeControlled ? 'controlled' : 'uncontrolled';\n  const mode = modeRef.current;\n\n  const handleChange = (nextValue: T | null) => {\n    typeof onChange === 'function' && onChange(nextValue);\n\n    // Controlled input only triggers onChange event and expects\n    // the controller to propagate new value back.\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(nextValue);\n    }\n  };\n\n  useEffect(() => {\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(effectiveValue);\n    }\n    typeof onValueUpdate === 'function' && onValueUpdate(effectiveValue);\n  }, [mode, effectiveValue]);\n\n  return [effectiveValue, handleChange, modeRef.current] as const;\n}\n"],"mappings":";;AACO,SAASA,eAAeA,CAAAC,IAAA,EAO5B;EAAA,IANDC,KAAK,GAAAD,IAAA,CAALC,KAAK;IACLC,YAAY,GAAAF,IAAA,CAAZE,YAAY;IACZC,UAAU,GAAAH,IAAA,CAAVG,UAAU;IACVC,IAAI,GAAAJ,IAAA,CAAJI,IAAI;IACJC,QAAQ,GAAAL,IAAA,CAARK,QAAQ;IACRC,aAAa,GAAAN,IAAA,CAAbM,aAAa;EAEb,IAAMC,kBAAkB,GAAGH,IAAI,CAACH,KAAK,CAAC;EACtC,IAAMO,OAAO,GAAGC,MAAM,CAAC,SAAS,CAAC;EACjC,IAAMC,YAAY,GAAGN,IAAI,CAACF,YAAY,CAAC,GAAGA,YAAY,GAAGC,UAAU;EACnE,IAAAQ,SAAA,GAAkDC,QAAQ,CAACF,YAAY,CAAC;IAAAG,UAAA,GAAAC,cAAA,CAAAH,SAAA;IAAjEI,iBAAiB,GAAAF,UAAA;IAAEG,oBAAoB,GAAAH,UAAA;EAC9C,IAAII,cAAc,GAAGV,kBAAkB,GAAGN,KAAK,GAAGc,iBAAiB;EACnE,IAAI,CAACR,kBAAkB,IAAIC,OAAO,CAACU,OAAO,KAAK,YAAY,EAAE;IAC3DD,cAAc,GAAGd,UAAU;EAC/B;EACEK,OAAO,CAACU,OAAO,GAAGX,kBAAkB,GAAG,YAAY,GAAG,cAAc;EACpE,IAAMY,IAAI,GAAGX,OAAO,CAACU,OAAO;EAC5B,IAAME,YAAY,GAAG,SAAfA,YAAYA,CAAIC,SAAS,EAAK;IAClC,OAAOhB,QAAQ,KAAK,UAAU,IAAIA,QAAQ,CAACgB,SAAS,CAAC;IACrD,IAAIF,IAAI,KAAK,cAAc,EAAE;MAC3BH,oBAAoB,CAACK,SAAS,CAAC;IACrC;EACA,CAAG;EACDC,SAAS,CAAC,YAAM;IACd,IAAIH,IAAI,KAAK,cAAc,EAAE;MAC3BH,oBAAoB,CAACC,cAAc,CAAC;IAC1C;IACI,OAAOX,aAAa,KAAK,UAAU,IAAIA,aAAa,CAACW,cAAc,CAAC;EACxE,CAAG,EAAE,CAACE,IAAI,EAAEF,cAAc,CAAC,CAAC;EAC1B,OAAO,CAACA,cAAc,EAAEG,YAAY,EAAEZ,OAAO,CAACU,OAAO,CAAC;AACxD"},"metadata":{},"sourceType":"module"}